<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CD Tracker</title>

<style>
body {
  margin: 0;
  background: #0d0f14;
  color: #e5e7eb;
  font-family: system-ui, -apple-system, sans-serif;
}

.container {
  padding: 12px;
}

.enemy {
  background: #161a22;
  padding: 14px;
  margin-bottom: 14px;
  border-radius: 14px;
}

.top-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 10px;
}

.champ-icon {
  width: 42px;
  height: 42px;
  border-radius: 8px;
  background: #0f141c;
  object-fit: cover;
}

.name {
  flex: 1;
  background: transparent;
  border: none;
  color: white;
  font-weight: bold;
  font-size: 18px;
  outline: none;
}

.level {
  display: flex;
  align-items: center;
  gap: 8px;
}

.level button {
  background: #232834;
  border: none;
  color: white;
  font-size: 18px;
  padding: 4px 10px;
  border-radius: 6px;
}

.toggles {
  display: flex;
  gap: 10px;
  font-size: 13px;
}

.toggle {
  cursor: pointer;
  opacity: 0.4;
}

.toggle.active {
  opacity: 1;
  color: #22c55e;
}

.spell-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 12px;
}

.spell-left {
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
}

.spell-icon {
  width: 38px;
  height: 38px;
  border-radius: 6px;
}

.timer {
  cursor: pointer;
  font-size: 22px;
  font-weight: bold;
}

.ready { color: #22c55e; }
.active { color: #ef4444; }
.warning { color: orange; }

</style>
</head>
<body>

<div class="container" id="app"></div>

<script>

const patch = "14.4.1"; // fallback

fetch('https://ddragon.leagueoflegends.com/api/versions.json')
  .then(res => res.json())
  .then(data => {
    if (Array.isArray(data) && data.length > 0) {
      patch = data[0];
      // Refresh the page so icons update
      console.log("Using patch:", patch);
      localStorage.removeItem("cdTracker"); // optionally clear stored icons first
      location.reload();
    }
  }).catch(err => {
    console.warn("Could not fetch latest patch, using fallback:", patch);
  });

const spellList = [
  { name: "Flash", cd: 300, icon: "SummonerFlash.png" },
  { name: "Ignite", cd: 180, icon: "SummonerDot.png" },
  { name: "Teleport", cd: 0, icon: "SummonerTeleport.png" },
  { name: "Heal", cd: 240, icon: "SummonerHeal.png" },
  { name: "Exhaust", cd: 240, icon: "SummonerExhaust.png" },
  { name: "Ghost", cd: 210, icon: "SummonerHaste.png" },
  { name: "Cleanse", cd: 210, icon: "SummonerBoost.png" },
  { name: "Barrier", cd: 180, icon: "SummonerBarrier.png" },
  { name: "Smite", cd: 90, icon: "SummonerSmite.png" }
];

function champIconURL(name) {
  const formatted = name.replace(/\s/g,'');
  return `https://ddragon.leagueoflegends.com/cdn/${patch}/img/champion/${formatted}.png`;
}

function spellIconURL(file) {
  return `https://ddragon.leagueoflegends.com/cdn/${patch}/img/spell/${file}`;
}

function teleportBase(level){
  if(level<=6)return 360;
  if(level<=10)return 300;
  return 240;
}

function adjustedCooldown(base,haste){
  return Math.round(base*(100/(100+haste)));
}

function formatTime(s){
  const m=Math.floor(s/60).toString().padStart(2,'0');
  const sec=(s%60).toString().padStart(2,'0');
  return `${m}:${sec}`;
}

class SpellTimer{
  constructor(saved=0){
    this.remaining=saved;
    this.interval=null;
  }

  start(duration,update){
    this.remaining=duration;
    this.tick(update);
  }

  tick(update){
    clearInterval(this.interval);
    this.interval=setInterval(()=>{
      if(this.remaining>0){
        this.remaining--;
        update();
        saveState();
      }else{
        clearInterval(this.interval);
        update();
        saveState();
      }
    },1000);
  }

  reset(update){
    clearInterval(this.interval);
    this.remaining=0;
    update();
    saveState();
  }
}

let enemiesState=JSON.parse(localStorage.getItem("cdTracker"))||[];

function saveState(){
  localStorage.setItem("cdTracker",JSON.stringify(enemiesState));
}

function createEnemy(i){

  const saved=enemiesState[i]||{
    name:"",
    level:1,
    boots:false,
    cosmic:false,
    crimson:false,
    spellIndex1:0,
    spellIndex2:1,
    remaining1:0,
    remaining2:0
  };

  enemiesState[i]=saved;

  let level=saved.level;
  let boots=saved.boots;
  let cosmic=saved.cosmic;
  let crimson=saved.crimson;
  let spellIndex1=saved.spellIndex1;
  let spellIndex2=saved.spellIndex2;

  const timer1=new SpellTimer(saved.remaining1);
  const timer2=new SpellTimer(saved.remaining2);

  const enemy=document.createElement("div");
  enemy.className="enemy";

  enemy.innerHTML=`
    <div class="top-row">
      <img class="champ-icon">
      <input class="name" value="${saved.name}" placeholder="Champion">
      <div class="level">
        <button class="minus">-</button>
        <span class="lvl">L${level}</span>
        <button class="plus">+</button>
      </div>
      <div class="toggles">
        <span class="toggle boots ${boots?'active':''}">ION</span>
        <span class="toggle cosmic ${cosmic?'active':''}">COS</span>
        <span class="toggle crimson ${crimson?'active':''}">CRI</span>
      </div>
    </div>

    <div class="spell-row">
      <div class="spell-left s1">
        <img class="spell-icon i1">
      </div>
      <span class="timer t1">Ready</span>
    </div>

    <div class="spell-row">
      <div class="spell-left s2">
        <img class="spell-icon i2">
      </div>
      <span class="timer t2">Ready</span>
    </div>
  `;

  const champIcon=enemy.querySelector(".champ-icon");
  const nameInput=enemy.querySelector(".name");
  const lvlSpan=enemy.querySelector(".lvl");
  const t1=enemy.querySelector(".t1");
  const t2=enemy.querySelector(".t2");
  const i1=enemy.querySelector(".i1");
  const i2=enemy.querySelector(".i2");

  function updateChampIcon(){
    if(nameInput.value){
      champIcon.src=champIconURL(nameInput.value);
    }
  }

  updateChampIcon();

  nameInput.oninput=()=>{
    saved.name=nameInput.value;
    updateChampIcon();
    saveState();
  };

  function haste(){
    return (boots?10:0)+(cosmic?18:0)+(crimson?20:0);
  }

  function getCD(spell){
    const base=spell.name==="Teleport"
      ?teleportBase(level)
      :spell.cd;
    return adjustedCooldown(base,haste());
  }

  function updateDisplay(timer,element,index){
    if(timer.remaining>0){
      element.textContent=formatTime(timer.remaining);
      if(timer.remaining<=10){
        element.className="timer warning";
      }else{
        element.className="timer active";
      }
    }else{
      element.textContent="Ready";
      element.className="timer ready";
    }
    if(index===1)saved.remaining1=timer1.remaining;
    if(index===2)saved.remaining2=timer2.remaining;
  }

  function updateSpellIcons(){
    i1.src=spellIconURL(spellList[spellIndex1].icon);
    i2.src=spellIconURL(spellList[spellIndex2].icon);
  }

  enemy.querySelector(".minus").onpointerdown=()=>{
    if(level>1)level--;
    saved.level=level;
    lvlSpan.textContent="L"+level;
    saveState();
  };

  enemy.querySelector(".plus").onpointerdown=()=>{
    if(level<18)level++;
    saved.level=level;
    lvlSpan.textContent="L"+level;
    saveState();
  };

  function toggle(el,setter,key){
    el.onpointerdown=()=>{
      setter();
      el.classList.toggle("active");
      saved[key]=!saved[key];
      saveState();
    };
  }

  toggle(enemy.querySelector(".boots"),()=>boots=!boots,"boots");
  toggle(enemy.querySelector(".cosmic"),()=>cosmic=!cosmic,"cosmic");
  toggle(enemy.querySelector(".crimson"),()=>crimson=!crimson,"crimson");

  enemy.querySelector(".s1").onpointerdown=()=>{
    spellIndex1=(spellIndex1+1)%spellList.length;
    saved.spellIndex1=spellIndex1;
    updateSpellIcons();
    saveState();
  };

  enemy.querySelector(".s2").onpointerdown=()=>{
    spellIndex2=(spellIndex2+1)%spellList.length;
    saved.spellIndex2=spellIndex2;
    updateSpellIcons();
    saveState();
  };

  t1.onpointerdown=()=>{
    if(timer1.remaining>0){
      timer1.reset(()=>updateDisplay(timer1,t1,1));
    }else{
      timer1.start(getCD(spellList[spellIndex1]),()=>updateDisplay(timer1,t1,1));
    }
  };

  t2.onpointerdown=()=>{
    if(timer2.remaining>0){
      timer2.reset(()=>updateDisplay(timer2,t2,2));
    }else{
      timer2.start(getCD(spellList[spellIndex2]),()=>updateDisplay(timer2,t2,2));
    }
  };

  updateSpellIcons();
  updateDisplay(timer1,t1,1);
  updateDisplay(timer2,t2,2);

  if(timer1.remaining>0)timer1.tick(()=>updateDisplay(timer1,t1,1));
  if(timer2.remaining>0)timer2.tick(()=>updateDisplay(timer2,t2,2));

  return enemy;
}

const app=document.getElementById("app");
for(let i=0;i<5;i++){
  app.appendChild(createEnemy(i));
}

</script>
</body>
</html>




